//                      ⣠⣤⣤⣤⣤⣤⣤⣄⡀
//                   ⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤
//                ⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤
//              ⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//            ⣾⣿⣿⣿⣿⣿⣿⣿⣿⠟       ⠻⢿⣿⣿⣿⣿⣿
//           ⣾⣿⣿⣿⣿⣿⣿⡿⠋           ⠻⣿⣿⣿⠟
//          ⣿⣿⣿⣿⣿⣿⣿⠋
//          ⣿⣿⣿⣿⣿⣿⣿
//          ⣿⣿⣿⣿⣿⣿⣿⡀
//          ⣿⣿⣿⣿⣿⣿⣿⣿⣷             ⣠⣤⣄
//           ⠻⣿⣿⣿⣿⣿⣿⣿⣿⣦         ⣾⣿⣿⣿⣿⣷
//             ⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿
//               ⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿
//                  ⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿
//                     ⠙⠿⠿⠿⠿⠿⠿⠿⠿⠟⠋

// ⢻⢭⡓⣆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠸⣏⢖⡲⣅⠀⠀
// ⣣⢾⡛⣜⢫⣦⠀⠀⢀⣤⠴⡦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣸⢏⡝⣆⢀
// ⢿⣧⢹⣬⡷⣚⣒⣶⡾⣍⡞⡱⣞⡇⠀⠀⠀⠀⢀⣠⢤⠖⣦⡤⠤⡶⠦⠤⣤⢶⠲⠤⣄⠀⠀⠀⠀⠀⢀⡤⠶⢶⢤⡀⢸⣛⣮⢞⡜⡚
// ⠈⡷⣻⢏⠶⣙⢶⣼⠟⡼⣜⡵⠋⠀⠀⠀⣠⠞⡩⢴⣿⣿⣾⣹⠐⢢⢁⡾⡵⠚⢻⣷⣤⡙⠲⢄⠀⠀⢾⣍⡻⣌⢧⣷⡾⡞⣥⢫⡝⣃
// ⠀⢻⣿⢊⣟⣾⢫⢇⡻⣱⢺⠁⠀⠀⠀⡼⣡⣿⣄⣀⡿⣿⣿⡏⡇⢢⢸⡿⣷⣤⣼⠿⢿⣿⣷⣎⣷⠀⠈⠳⣵⡩⢖⡻⣱⢻⣌⡳⢎⡵
// ⠀⠀⢻⡧⢞⡧⣋⣮⣕⡣⢿⠀⠀⢀⡼⢃⣻⢿⣿⣿⣧⠾⠟⡙⣧⣂⣌⢣⡛⡿⠿⠷⠾⠿⠿⠣⣌⠳⡀⢰⢯⡱⣫⡶⢥⣛⢮⡓⣏⢶
// ⠀⠀⠈⢯⡧⣓⢧⡚⣽⣞⡾⠀⢀⡞⠠⣿⠀⡰⢂⣖⣤⣯⣾⣿⣿⣿⣿⣿⣿⣇⠄⣎⣱⣉⢎⡱⣘⡇⠹⡞⣮⢵⢯⣱⠳⡬⢧⡙⣦⠋
// ⠀⠀⠀⠈⠳⣭⢲⡹⢲⡞⠁⠀⣼⢐⠡⡙⠳⠗⡛⣩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⡁⡉⠛⣶⣵⠋⡐⢿⠈⠻⣆⢧⡛⢜⣣⠟⠁⠀
// ⠀⠀⠀⠀⠀⠈⠉⠉⠁⠀⠀⢰⡇⢊⠔⡡⢊⠔⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡈⠡⣿⢹⡄⢡⢚⣇⠀⠈⠉⠉⠉⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⢊⠤⢑⠢⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⢹⠃⢢⢻⡄⢊⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣇⠌⢢⠁⢎⣿⣿⣿⣿⣿⣿⣿⠿⠟⠿⢿⣿⣿⣿⣿⣿⣿⣏⡄⢣⢺⡇⢼⡋⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡊⠤⠉⢼⣿⣿⣿⣿⠿⠋⡄⠒⡌⢢⠐⡌⠻⣿⣿⣿⣿⣯⠛⢓⠛⣠⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⡘⡏⣿⣿⣿⡿⠋⡄⠣⠌⡱⢈⠄⢣⠐⡡⠘⢿⣿⣿⣿⡐⣌⢒⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⡅⠸⠿⢛⡡⠘⡄⠣⡘⠄⠣⡘⠄⢣⠐⣉⠂⠻⢿⠿⠁⢼⡲⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⣁⠦⠟⡁⢣⠐⡡⠂⡍⠰⢁⠎⡄⠣⢄⡉⠲⢦⣂⣉⢴⠗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⢲⢥⣂⠅⣂⠑⡈⢅⠊⡐⠌⢡⢂⣌⣡⠶⣛⣙⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

#include <jpeg2ppm.h>


int main(int argc, char **argv) {
    if (argc == 1) {
    	/* 
            Si y'a pas au moins un argument en ligne de commandes, on
    	    boude. 
        */
    	fprintf(stderr, "Usage: %s fichier.jpeg\n", argv[0]);
    	return EXIT_FAILURE;
    }

    // Mode verbose
    if (argc > 2){
        if (strcmp(argv[2], "-v") == 0){
            setVerbose(true);
        } else if (strcmp(argv[2], "-hv") == 0){
            setVerbose(true);
            setHighlyVerbose(true);
        }
    }

    char *filename = argv[1];

    struct JPEG *jpeg = extract(filename);
    if (jpeg == NULL) return EXIT_FAILURE;

    if (decode_bitstream(jpeg)) {
        free_JPEG_struct(jpeg);
        return EXIT_FAILURE;
    };

    if (inv_quantize(jpeg)) {
        free_JPEG_struct(jpeg);
        return EXIT_FAILURE;
    };

    if (IZZ(jpeg)) {
        free_JPEG_struct(jpeg);
        return EXIT_FAILURE;
    };

    if (IDCT(jpeg)) {
        free_JPEG_struct(jpeg);
        return EXIT_FAILURE;
    };

    if (YCbCr2RGB(jpeg)) {
        free_JPEG_struct(jpeg);
        return EXIT_FAILURE;
    };

    if (write_ppm(filename, jpeg)) {
        free_JPEG_struct(jpeg);
        return EXIT_FAILURE;
    };


    fprintf(stderr, "Image %s décodée avec succès !\n", filename);


    // On ne gère que 3 composantes au maximum
    // Vérifier que la longueur lue dans chaque segment correspond bien à la longueur annoncée du segment
    // thread par composante pour accélérer le traitement pour toutes les étapes après decoding_bitstream
    // on ne gère pas les fichiers polyglotes (sauf si le jpeg est en début de fichier)
    // Note -8 : factoriser les nb_mcus_width * nb_mcus_height
    // Note -6 : vérifier App0 = JFIF
    // Note -3 : peut être réajuster width et height en size_t si on a une image hyper grande ... ???
    // Note -2 : il faut forcer la taille de nos variables avec int8_t, int16_t, int32_t, uint8_t, uint16_t, uint32_t pour éviter les problèmes de taille de variables sur différentes architectures matérielles !!!
    // Note 0 : prévoir de détecter si image N&B, couleur ou couleur avec alpha (>nb de composantes ?) pour adapter le décodage du bitstream en conséquence !!!
    // Note 1 : prévoir de repasser toutes les structures en [8][8] ou [64] pour optimiser l'utilisation mémoire et accélérer l'exécution du programme !!!
    // Note 2 : prévoir de reformater nos sorties du mode verbose pour rendre la lecture plus facile&jolie ... s'inspirer de jpeg2blabla ?
    // Note 3 : prévoir de refaire des vrais tests avec toutes ces fonctions modifiées depuis début de semaine !!!
    
    
    // On libère la mémoire
    free_JPEG_struct(jpeg);

    printf("\a");


    return EXIT_SUCCESS;
}
